\documentclass[10pt]{article}

\usepackage{fullpage}
\usepackage{listings}
\usepackage{comment}
\title{COS 597B: Final Report\\
\emph{Towards SMT in VST}

\author{\emph{Santiago Cuellar, Olivier Savary B\'{e}langer}} 

\begin{document}
\maketitle


%start
\section{Introduction}
When formally proving the function correctness of programs, a portion of the proof or lemmas require a level of intuition or higher-order reasoning which goes beyond what is supported by automated theorem prover. However, between these crucial steps are many mechanical ones. Certain interactive theorem provers such as Coq provide scripting facilities to automate these steps, but this limited form of automation is ad hoc and brittle. It has been observed that many of these steps corresponds to reasoning over STM theories which can be performed by existing STM solvers. 

The goal of the project is to investigate using an SMT solver to discharge obligations generated by VST. After investigated the currently available tools to interface Coq and SMT solvers, we found out that SMTCoq already implements a pipeline from Coq goals to SMTLib and back into Coq after being solved by an SMT solver producing evidences. However, limitations in the current versions of SMTcoq, SMTlib and SMT solvers interfacing with SMTlib and SMTcoq prevent us from experimenting this pipeline. Our contribution are
\begin{itemize}
 \item identify goals in VST development which could be reduce to formulas in SMT theories
 \item identify the theories needed for such development to be useful
 \item define encoding of list-reasoning in the theory of arrays with uninterpreted functions (\emph{QF\_AUFLIA})
 \item prove the soundness of this encoding (TODO)
  \item sketch a complete pipeline connecting VST to an SMT solver assuming minimal updates to external tools
\end{itemize}
\section{Context}
% VST

% SMT COQ

% QF_AX, QF_AULIA and their support (and proof generation)

\section{Overview of our Solution}



%dev

\section{Encoding Lists as Arrays}

% difference between list and QF_AX

% encoding of nth

% encoding of upd

% encoding of append

\section{Reflecting Back on Lists}
% explanation of proof needed for the big picture to work
While we strive for correctness of encoding, differences between lists
and the infinite arrays as manipulated by \emph{QF\_AX} makes such encoding difficult to achieve in general. 
Fortunately, we can instead using a sound, but incomplete encoding, such that the validity 
of the encoding implies the validity of the original formula, but not the other way around.
In other word, some valid goals may result in invalid encodings, but valid encoding only arrises from valid goals.

% proof of soundness of encoding
%% QF_AX as Array GDT + Axioms

%% nth as select

%% upd_nth as store

%% ++ as branch-and-select


%end
\section{Future Work}
% 4 pages just there

% VST <-> SMTLIB

%SMTlib <-> CVC4

\section{Conclusion}

\end{document}
