\documentclass[10pt]{article}

\usepackage{fullpage}
\usepackage{listings}
\usepackage{comment}
\title{COS 597B: Final Report\\
\emph{Towards SMT in VST}}

\author{\emph{Santiago Cuellar, Olivier Savary B\'{e}langer}} 

\begin{document}
\maketitle


%start
\section{Introduction}
When formally proving the function correctness of programs, a portion of the proof or lemmas require a level of intuition or higher-order reasoning which goes beyond what is supported by automated theorem prover. However, between these crucial steps are many mechanical ones. Certain interactive theorem provers such as Coq provide scripting facilities to automate these steps, but this limited form of automation is ad hoc and brittle. It has been observed that many of these steps corresponds to reasoning over STM theories which can be performed by existing STM solvers. 

The goal of the project is to investigate using an SMT solver to discharge obligations generated by VST. After investigated the currently available tools to interface Coq and SMT solvers, we found out that SMTCoq already implements a pipeline from Coq goals to SMTLib and back into Coq after being solved by an SMT solver producing evidences. However, limitations in the current versions of SMTcoq, SMTlib and SMT solvers interfacing with SMTlib and SMTcoq prevent us from experimenting this pipeline. Our contribution are
\begin{itemize}
 \item identifing goals in VST development which could be reduce to formulas in SMT theories
 \item identifing the theories needed for such development to be useful
 \item sketching a completed pipeline assuming minimal updates to relevant tools
 \item defining encoding of list-reasoning in the theory of arrays with uninterpreted functions (\emph{QF\_AUFLIA})
 \item proving the soundness of this encoding (TODO)
\end{itemize}
\section{Context}
% VST

% SMT COQ

% QF_AX, QF_AULIA and their support (and proof generation)
\subsection{The SMT Theory of Arrays}
The extensional theory of arrays is an SMT theory to reason about integer-indexed, infinite collection of elements. Arrays are accessed using function \lstinline|select| of type \lstinline|array -> int -> el| and modified with function \lstinline|store| of type \lstinline|array -> int -> el -> array|. The simplest fragment of this theory is \emph{QF\_AX}. This quantifier-free theory is based on three axioms:
\begin{enumerate}
\item selecting the last store:
$$ \forall a i, \textsf{select } (\textsf{store } a i e) i = e$$
\item selecting from a previous store:
$$ \forall a i j, i \neq j \to \textsf{select } (\textsf{store } a j e) i = \textsf{select } a i$$
\item and extensionality:
$$ \forall a b, (\forall i, \textsf{select } a i = \textsf{select } b i) \to a = b$$
\end{enumerate}

\section{Overview of our Solution}

In the remainder of this report, we present our solution which consist of encoding list operations as operation over arrays in various SMT theories. While simple operations such as \lstinline|nth| and \lstinline|upd_nth| can be encoded in the quantifier-free fragment of the theory of array with uninterpreted functions and linear arithmetic \emph{QF\_AUFLIA}, other operations require stronger theories such as \emph{AUFLIA}. 

Targeting \emph{QF\_AUFLIA} is a pragmatic choice. While the theory of inductive datatypes would lead to a direct encoding of lists and list operations, its support is not planned for SMTcoq and would require significant extension to SMTlib and CVC4 (which supports the theory but doesn't generate proof witness for it). 

%dev

\section{Encoding Lists as Arrays}

% difference between list and QF_AX
In Coq, lists are an inductive datatype representing an ordered collection of finitely many elements of a given type. 
\begin{lstlisting}
inductive list A : Set :=
 | nil : list A
 | cons : A -> list A -> list A.
\end{lstlisting}

In VST, C arrays are reasoned about propositionally as list, using total operation such as \lstinline|upd_Znth| and \lstinline|nthZ|, using mathematical integers as index and a default value as argument to \lstinline|nthZ| returned when accessing the array out of bound. 

As seen in the previous section, the arrays manipulated in \emph{QF\_AX} are associative arrays rather than programmatic ones. They represent an infinite collection of key-value pair where the keys are mathematical integers. 

The basis of our encoding is that the \emph{QF\_AX} array \lstinline|a| representing Coq list \lstinline|l| will be constrained to contain the same elements as \lstinline|l| from indices $0$ to $\mathsf{length} l - 1$ and the default value $d$ otherwise.This means that it should always be the case that
$$ a_i = nthZ\ l\ i d$$

% encoding of nth

% encoding of upd

% encoding of append

\section{Reflecting Back on Lists}
% explanation of proof needed for the big picture to work
While we strive for correctness of encoding, differences between lists
and the infinite arrays as manipulated by \emph{QF\_AX} makes such encoding difficult to achieve in general. 
Fortunately, we can instead using a sound, but incomplete encoding, such that the validity 
of the encoding implies the validity of the original formula, but not the other way around.
In other word, some valid goals may result in invalid encodings, but valid encoding only arises from valid goals.

% proof of soundness of encoding
%% QF_AX as Array GDT + Axioms

%% nth as select

%% upd_nth as store

%% ++ as branch-and-select


%end
\section{Future Work}
% 4 pages just there
In the near future, we expect most of the current limitations to our work due to external tools to be lifted.

At the very least, we need CVC4 to generate witnesses for the theory of arrays and SMTcoq to support the theory of arrays and to interface with CVC4. We have the confirmation from the developer of CVC4 and SMTcoq that these are being worked on. In the future, supports for more theories, especially quantified arrays and inductive datatypes, would permit for more direct encodings and, in the case of the latter, automatic generation of encoding together with correctness proof for the datatype and simple functions.

% supporting more list operations and potentially other datatypes
In the meantime, we can extend our encodings with more lists operations, potentially using \emph{AUFLIA} rather than its quantifier-free fragment \emph{QF\_AUFLIA}.
\section{Conclusion}

\end{document}
